---
title: 基本语法
category: 编程语言
tag: C
author: JQiue
article: false
---

这里是 C 语言的基本语法规则

## 注释

```c
// 单行注释，只能注释单行

/*
多行注释
可以注释多行内容
*/
```

## 代码块和语句

C 语言采用`{}`来区分代码之间的层次，每条语句必须以`;`结束

## 标识符

+ 由英文字母，数字和下划线组成，但第一个字符不能是数字
+ 不能是 C 语言中的**关键字**和**保留字**
+ 区分大小写

## 变量

C 是一个静态类型语言，必须声明变量的数据类型，且必须初始化后才能使用，但是并没有强制初始化，如果不赋值初始化，访问变量会得到一个无法估测的数据，并且变量的数据类型不可以随意改变，通过`=`赋值运算符来初始化或修改变量的值

```c
int foo; // 声明
int bar  = 33; // 声明同时初始化
int foobar, barbaz; // 同时声明多个变量
foo = 11; // 第一次赋值即初始化
foo = 22; // 再次赋值即修改
foo = baz = 44; // 连续赋值，从右向左结合
```

## 常量

**字面常量**即一眼就能看出它的值，比如`3.14`就是一个字面常量，它不能被修改

```c
// 整型常量
1;
7.;     // 整型是可以省略小数点的，也可加上
0b1111; // 二进制
027;    // 八进制
0x26;   // 十六进制

// 浮点型常量
10.2f;  // 在 C 语言中默认是双精度常量，可以通过在常量后加 `f` 符号表示单精度
3.14;   // 双精度常量
.7;     // 如果整数为 0 可以省略不写
4.5e0;  // 指数表示形式，大写 E 和小写 e 都可以，e 后面必须是整数，且前面必须有一个数字

// 字符型常量
'a';
'3';
'\n'; // 转义字符
'啊'; // error，在 c 里面中文字符不算一个字符，必须是 ASCII 码表上的字符

// 字符串常量
"h";
"hello";
"你好";  // 字符串是可以使用中文的
```

C 语言用`const`定义符号常量，这个常量也是不可以被改变的，且在定义的时候必须初始化

```c
const int pi = 3.14;
pi = 3.1415; // error，常量是不可以被修改的
```

## 数据类型

### 基本类型

+ 整型
  + 短整型（short）：占 2 byte，表示的整数范围较小
  + 整型（int）：占 4 byte，表示的整数范围较大
  + 长整型（long）：占 4 byte，表示的整数范围最大
+ 浮点型
  + 单精度（float）：占 4 byte，小数点后面的精度相对较小
  + 双精度（double）：占 8 byte，小数点后面的精度相对较大
+ 字符型（char）：占 1 byte

### 构造类型

+ 数组
+ 结构体
+ 共用体
+ 枚举类型

### 指针类型

### 空类型

::: tip 不同进制的整数表达方式

+ 二进制用`0b`表示
+ 八进制用`0`表示
+ 十进制不需要添加任何额外符号
+ 十六进制用`0x表示
:::

::: tip
字符在计算机中是按字符的 ASCII 值存储的，本质是个整数，输出的时候按不同的格式占位符可得到不同的的显示：`%c` 按字符输出，`%d` 按整数输出，如果对字符进行数值运算，实际上是算的 ASCII 码中的对应的数值
:::

::: tip 转义字符
字符也可以用`\`开头的特殊序列表示

控制符|功能
---|---
\a|警报
\b|退格
\n|换行
\t|空格
\\|斜杠
\'|单引号
\"|双引号
\ddd|1-3 位 8进制表示的字符（用数字替换d）
\xhh|1-2 位 16进制表示的字符（x是固定的只需用数字替换h）
:::

### 类型检测

C 语言可以使用`sizeof`来判断数据类型

### 类型转换

1. 自动类型转换：编译器根据上下文环境自动判断，通常转换为范围更大的类型
2. 强制类型转换：由程序员显式的转换数据类型

```c
float foo;
int bar = 3;
foo = bar; // 将整型变量的数据赋值给浮点型会转化自动转换为浮点
printf("foo = %f", foo); // 输出 3.000000
bar = 0.123456; // 将浮点型常量赋值给整型变量会舍去精度
printf("bar = %d", bar); // 输出 0
```

::: tip
对于 printf() 函数来说，任何小于 int 类型的都会被转换成 int，float 会被自动转换为 double，但是 scanf() 函数不会，scanf() 必须要知道输入的数据类型，比如 short，就要用 %hd
:::

## 运算符

### 常见运算符

运算符|描述
---|---
+|相加
-|相减
*|相乘
/|相除
%|取余
==|判断相等
!=|判断不相等
\>|判断左操作数是否大于右操作数
<|判断左操作数是否小于右操作数
\>=|判断左操作数是否大于等于右操作数
<=|判断左操作数是否小于等于右操作数
&&|逻辑与，两个操作数都非0，则为真
\|\||逻辑或，两个操作数有一个非0，则为真
!|逻辑非，逆转操作数的逻辑状态，真则为假，假则为真
=|赋值运算符
+=|加且赋值运算符，右操作数和左操作数相加并赋值给左操作数
-=|减且赋值运算符，右操作数和左操作数相减并赋值给左操作数
*=|乘且赋值运算符，右操作数和左操作数相乘并赋值给左操作数
/=|除且赋值运算符，右操作数和左操作数相除并赋值给左操作数
&|取地址运算符
*|取引用的对象运算符
,|从左往右计算，将最右边的结果返回

::: tip
关系运算符和逻辑运算符都会产生 0 或 1 ，在 C 语言中，任何非 0 的值就为真
:::

### 三元运算符

三元运算符是一种条件运算，即通过`?`来构成条件选择，和`if else`差不多，如果满足就执行第一个结果，否则就执行另外一个结果

```c
int a = 3, b = 4, c;
c = a > b ? 5 : 6; // 如果 a 大于 b 为真，则将执行第一个表达式，否则执行另一个表达式
```

### 优先级和结合性

优先级决定谁先计算，结合性指的是当算子两边的运算符优先级别相同时，则按照结合性来确定表达式谁先计算

+ ! > 算数 > 关系 > 逻辑 > 赋值
+ 单目 > 双目

## 流程控制

### 顺序结构

C 语言默认的执行结构，从上到下逐行逐句执行

```c
int main(void){ // 从函数代码块开始依次执行语句
  int a;
  a = 2;
  return 0; // 当函数遇到 return 语句时会立即结束运行
}
```

### 分支结构

+ 单分支：通过`if`关键字来定义，条件满足则执行代码块中的语句

```c
int age;
scanf("%d", &age);
if (age >= 18){
  printf("你已经成年啦！");
}
```

+ 双分支：通过`else`关键字与`if`匹配，如果`if`条件不满足，则执行`else`代码中的语句，`else`不需要判断条件

```c
int age;
scanf("%d", &age);
if (age >= 18){
  printf("你已经成年啦！");
} else {
  printf("你还没成年呢！");
}
```

+ 多分支：如果需要更复杂的逻辑判断，可以使用多重`if else`搭配实现

```c
int score;
scanf("%d", &score);
if (score >= 90){
  printf("优秀");
} else if (score >= 80){
  printf("良好");
} else if (score >= 60){
  printf("及格");
} else {
  printf("不及格");
}
```

+ switch：相对于`if`语句来说，`switch`可以更方便的控制多个分支的流程控制，不过和`if`不同的是，`switch`语句必须精确的匹配一个正确的值才能执行相应的`case`，而且会从当前`case`一直执行下去，所以需要给每个`case`添加`break`语句来打断后续的执行

```c
int week;
scanf("%d", &week);
switch (week){
  case 1:
    printf("星期一");
    break;
  case 2:
    printf("星期二");
    break;
  case 3:
    printf("星期三");
    break;
  case 4:
    printf("星期四");
    break;
  case 5:
    printf("星期五");
    break;
  case 6:
    printf("星期六");
    break;
  case 7:
    printf("星期天");
    break;
  default:
    printf("error");
  }
  return 0;
```

### 循环结构

+ while：`while`常用于已知的循环次数

如果想要打印 5 遍：`hello,world!`，如果不用循环：

```c
printf("hello,world!");
printf("hello,world!");
printf("hello,world!");
printf("hello,world!");
printf("hello,world!");
```

如果要打印 100 遍，还需要这个写法吗，而用`while`就可以这么写：

```c
int i = 0;
while (i < 100) {
   printf("hello,world!");
   i++;
}
```

循环一定要有终止条件，否则会导致死循环产生

::: tip 死循环
即开发人员忘记修改循环体内的判断条件，导致循环一直执行，程序无法终止
:::

+ do while：`do while`循环不管条件是否满足，都会先执行一次才会判断条件

```c
int i = 0;
do {
   printf("hello,world!");
   i++;
} while (i < 0);
```

::: danger
不能忘记这个分号
:::

+ for：`for`通常用于循环次数不确定的情况

```c
for (表达式 1;判断条件;表达式 2){
  // code
}
```

执行流程：

1. 执行表达式 1，并且只会被执行一次
2. 判断条件是否为真
3. 为真则执行代码块中的代码，然后执行表达式 2，重复 2 - 3 步的操作
4. 为假则立即结束整个循环

表达式 1 通常用于初始化变量，可以省略，判断条件用于决定循环体是否执行，表达式 2 通常用于控制循环的终止条件，也可以省略。**只保留两个`;`时，产生死循环**

### 循环打断

有时候不需要循环到一定次数才终止，需要手动终止循环，C 语言提供了两种打断方式：

+ 当遇到`break`语句时，立即退出离`break`语句最近的一层循环，不继续下一次循环
+ 当遇到`continue`语句时，立即退出当前次循环，继续下一次循环

## 函数

C 语言源程序是由函数组上程序往往由多个函数组成，由主成的，一个程序中有且只有一个主函数`main`，它是程序的入口（开始）和出口（结束），但实际函数调用其他函数，其他函数也可以互相调用，函数是源程序的基本模块，C 语言的函数本质是一个复合语句，用来执行一个**语句序列**。C 语言虽然提供了大量的库函数，但是仍然满足不了一些开发中的逻辑，这就需要用户自定义函数的功能

### 函数的定义

定义函数就像定义一个变量一样，需要声明数据类型，声明标识符，然后通过`()`来区分它是否为一个函数，后面跟上用`{}`包裹的语句序列，`{}`也叫**函数体**

```c
数据类型 标识符(){
  // code...
  return;
}
```

对于一个函数来说，必须主动调用才能够执行对应的语句序列

### 函数的返回值

函数本身是一个表达式，结果使用可以使用`return`关键字返回，返回类型必须符合定义函数时的数据类型，当执行到`return`语句时，函数会立即结束并返回结果

```c
int getValue(){
  return 2333;
}

getValue();
```

### 函数的参数

函数在定义的时候可以在`()`定义参数，用来接受外部传入的数据，定义参数的函数叫**有参函数**，反之叫**无参函数**，有参函数相对于无参函数来说更加灵活

```c
int add(int a, int b){
  return a + b;
}
add(1, 2);
```

定义在`()`的变量叫**形参**，形参只在函数内部有效，当函数调用完毕时就会被销毁，通过调用传入的参数叫**实参**，参数传递时，实参和形参在**数量上**，**类型上**，**顺序上**应严格一致，否则会发生”类型不匹配”的错误

### 函数的原型

原则上函数定义必须在调用函数之前出现，如果在调用函数之前，编译器没有发现函数的定义则会抛出错误，这个问题可以通过定义函数的原型来解决，用来告诉编译器：**这个函数我声明了，但是定义在后面**

```c
int add(int, int);
int sub(int, int);

int main(void){
  add(1, 2);
  sub(3, 2);
  return 0;
}

int add(int a, int b){
  return a + b;
}

int sub(int a, int b){
  return a - b;
}
```

::: danger
声明原型的时候参数可以只写数据类型，如果写了标识符，后面实现函数中的标识符必须一样
:::

## 数组

```c
int arr[3];
float arr[5];
```

数组的初始化是在编译阶段进行的

1. 完全初始化：即数组多长就给多少个初始化值
2. 部分初始化：只给了少于数组长度的初始化值，没有被初始化的部分会被赋值为 0
3. 没有初始化

```c
int arr1[3] = {1, 2, 6};
int arr2[3] = {3};
int arr3[3];
```

::: danger 数组的越界访问
C 语言不会检查数组的越界访问，使用数组索引范围之外的索引值并不会报错
:::

### 二维数组

数组中的每一个元素也可以是一个数组，因此就有了多维数组的存在，最常用的是二维数组

```c
int arr[3][2];
```

::: tip
在二维数组中可以不用写行数，但列数必须写
:::

## 字符串

C 语言是不能定义字符串类型的，即只能通过一个个的字符序列来实现字符串，一般有两种格式

1. char 数组名[长度] = "字符串值";
2. char 数组名[长度] = {'字符1','字符2','字符3',...,'\0'};

通过观察发现字符串实际上是一个字符型数组来实现的，其中长度可以省略不写，且第二个方式最后一个元素必须是'\0'，它表示字符串的结束标识，并且不能够写中文，第一种可以写

输出一个字符串通常使用`%s``，但更常用的是使用 puts 函数和 gets 函数来输出和输入字符串

## 枚举类型

枚举类型是 C 语言提供的一种特殊类型，通常用于一些有限值范围的类型，用`enum`关键字声明，必须在函数外部定义，每一个取值都会被当作一个只读变量，默认第一个变量的取值为 0，之后的每一个变量取值会依次递增，如果给某一个位置的成员主动赋值，之后的每一个变量会在这个取值的基础上自增

```c
enum en{
  foo,
  bar
};
int main(void){
  printf("%d", foo); // 0
  printf("%d", bar); // 1
  return 0;
}
```

对于枚举类型的成员来说，只能在定义的时候赋值，且只能够赋值整型数据，也可以是字符型（因为字符型在内存中是以数字存储的），访问成员时也只需要使用成员标识符即可

也可以通过枚举类型来定义一个普通变量或指针变量，普通变量也是只读的，最好在定义是初始化，否则会是一个垃圾数据

```c
enum en{
  foo,
  bar
};
int main(){
  enum en baz = 1;
  enum en *qux = &baz;
  printf("%d", baz); // 1
  printf("%d", &qux); // 1
  return 0;
}
```

## 输入和输出

必须引入`stdio.h`头文件

+ printf

printf 常用于打印一些信息到屏幕上，是使用的最频繁的函数，也叫做**格式化输出函数**。它会将接收的一个字符串参数打印到屏幕上

```c
printf("2"); // 2
```

它通常和格式化占位符搭配使用来实现不同字符串的打印

```c
printf("今年我%d岁还单身", 18); // 今年我18岁还单身
```

会发现`18`将`%d`给替换了，这个`%d`就是格式化占位符中的一种，这说明`printf`第一个参数之外的参数都可以通过占位符来替换第一个参数中指定的部分，他们都是按顺序的

```c
printf("余额宝今日又增加了%d的收益", 0.01); // 余额宝今日又增加了1202590843的收益
printf("余额宝今日又增加了%f的收益", 0.01); // 余额宝今日又增加了0.010000的收益
```

在上面这个例子中，很显然`%d`不能够帮浮点数正确的显示，而`%f`可以，这说明不同的数据类型应使用不同的格式化占位符，下面是一些常用的格式化占位符：

类型|含义
---|---
d|整数
f|单，双精度浮点(带有 6 位小数)
o|无符号八进制
x|无符号十六进制
c|字符
s|字符串
p|地址

然而这只是占位符中的一种用法，占位符还可以决定数据如何显示，比如控制小数点位数：

```c
printf("余额宝今日又增加了%.2f的收益", 0.01); // 余额宝今日又增加了0.01的收益
```

控制字符输出宽度：

```c
printf("今年我%5d岁还单身", 18); // 今年我   18岁还单身
printf("今年我%-5d岁还单身", 18); // 今年我18   岁还单身
printf("今年我%05d岁还单身", 18); // 今年我00018岁还单身
printf("余额宝今日又增加了%4.2f的收益", 0.01); // 余额宝今日又增加了0.01的收益
printf("余额宝今日又增加了%5.2f的收益", 0.01); // 余额宝今日又增加了 0.01的收益
printf("余额宝今日又增加了%-5.2f的收益", 0.01); // 余额宝今日又增加了0.01 的收益
printf("余额宝今日又增加了%05.2f的收益", 0.01); // 余额宝今日又增加了000.01的收益
```

`%`后面不仅可以指定类型，精度，也可以指定宽度，当输出的位数小于指定宽度时会在左边使用空格补齐，输出的位数大于指定宽度会按原样输出，如果给宽度指定`-`，则会从右边补齐空格。也可以指定`0`来补齐，只适用不加`-`的情况下

+ scanf

+ getchar

+ putchar

### 格式化输出
